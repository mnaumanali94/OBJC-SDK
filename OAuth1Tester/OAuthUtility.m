//
//  OAuthUtility.m
//
//  This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 08/03/2016
//
#import "OAuthUtility.h"

@implementation OAuthUtility

const NSString* OAUTH_TOKEN = @"oauth_token";
const NSString* OAUTH_CONSUMER_KEY = @"oauth_consumer_key";
const NSString* OAUTH_NONCE = @"oauth_nonce";
const NSString* OAUTH_TIMESTAMP = @"oauth_timestamp";
const NSString* OAUTH_SIGNATURE = @"oauth_signature";
const NSString* OAUTH_SIGNATURE_METHOD = @"oauth_signature_method";
const NSString* OAUTH_VERSION = @"oauth_version";
const NSString* OAUTH_VERSION_NO = @"1.0";
const NSString* HMAC_SHA1 = @"HMAC-SHA1";
const NSString* OAUTH_HEADER_FORMAT = @"OAuth %1$@";
const NSString* OAUTH_HEADER_NAME = @"Authorization";

/**
* Appends the necessary OAuth credentials for making this authorized call
* @param	request	The out going request to access the resource
*/
+(void) appendOAuthParams:(HttpRequest*) request
{

    if ([APIHelper isNullOrWhiteSpace: Configuration_OAuthClientId])
        @throw([NSException exceptionWithName: @"IllegalArgumentException"
                                       reason: @"The given parameter value for \"OAuthClientId\" is invalid"
                                     userInfo: nil]);
                                     
    else if ([APIHelper isNullOrWhiteSpace: Configuration_OAuthClientSecret])
        @throw([NSException exceptionWithName: @"IllegalArgumentException"
                                       reason: @"The given parameter value for \"OAuthClientSecret\" is invalid"
                                     userInfo: nil]);

    else if ([APIHelper isNullOrWhiteSpace: Configuration_OAuthToken])
        @throw([NSException exceptionWithName: @"IllegalArgumentException"
                                       reason: @"The given parameter value for \"OAuthToken\" is invalid"
                                     userInfo: nil]);

    else if ([APIHelper isNullOrWhiteSpace: Configuration_OAuthTokenSecret])
        @throw([NSException exceptionWithName: @"IllegalArgumentException"
                                       reason: @"The given parameter value for \"OAuthTokenSecret\" is invalid"
                                     userInfo: nil]);

    int random = arc4random();
    NSMutableDictionary* parameters = [[NSMutableDictionary alloc] init];
    [parameters addEntriesFromDictionary:
     @{
       OAUTH_CONSUMER_KEY: Configuration_OAuthClientId,
       OAUTH_NONCE: [NSString stringWithFormat:@"%d", random],
       OAUTH_TIMESTAMP: [self getUnixTimeString],
       OAUTH_SIGNATURE_METHOD: HMAC_SHA1,
       OAUTH_VERSION: OAUTH_VERSION_NO,
       OAUTH_TOKEN: Configuration_OAuthToken
     }];
    
    NSString* signature = [self generateSignatureWithClientSecret: Configuration_OAuthClientSecret
                                                    andRequestURL: [[NSURL alloc] initWithString:[request queryUrl]]
                                                        andMethod: [self getHTTPMethodAsString: request]
                                                   andTokenSecret: Configuration_OAuthTokenSecret
                                                    andParameters: parameters];
    
    [parameters setObject: signature forKey:OAUTH_SIGNATURE];
    NSString* authHeaderVal = [self joinForHeader: parameters];
    
    [parameters setObject: [NSString stringWithFormat:OAUTH_HEADER_FORMAT, authHeaderVal]
                   forKey: OAUTH_HEADER_NAME];
    
    [parameters addEntriesFromDictionary:[request headers]];
    
    request.headers = parameters;
}

+(NSString*) generateSignatureWithClientSecret:(const NSString*) consumerSecret
                                 andRequestURL:(NSURL*) uri
                                     andMethod:(const NSString*) method
                                andTokenSecret:(const NSString*) tokenSecret
                                 andParameters:(NSDictionary*) parameters
{
    NSString* hmacKeyBase = [NSString stringWithFormat:@"%1$@&%2$@",
                             [self urlEncode: consumerSecret],
                             [self urlEncode: tokenSecret]];
            
    NSMutableDictionary* queryParams = [[NSMutableDictionary alloc] initWithDictionary:
                                        [self parseQueryString: [uri query]]];
    
    [queryParams addEntriesFromDictionary: parameters];
    
    NSString* stringParameter = [self formatQueryString: queryParams];
    NSString* port = @"";
    //Checks if it's a default port number
    if (!(([uri.scheme isEqualToString:@"http"] && [uri.port isEqualToNumber:@80])||([uri.scheme isEqualToString:@"https"] && [uri.port isEqualToNumber:@443])))
        port = [NSString stringWithFormat: @":%1$@", uri.port];

    NSString* signatureBase = [NSString stringWithFormat: @"%1$@&%2$@&%3$@", method,
         [self urlEncode: [NSString stringWithFormat:@"%1$@://%2$@%3$@%4$@", uri.scheme, uri.host, port, uri.path]],
         [self urlEncode: stringParameter]];

    NSData* hash = [self computeHashOfData: signatureBase usingKey: hmacKeyBase];
    return [self urlEncode:[hash base64EncodedStringWithOptions: 0]];
}

+(NSData*) computeHashOfData:(NSString*) data usingKey: key
{
    NSData* secretData  = [key dataUsingEncoding: NSUTF8StringEncoding];
    NSData* clearTextData = [data dataUsingEncoding: NSUTF8StringEncoding];
    unsigned char result[CC_SHA1_DIGEST_LENGTH];
    CCHmac(kCCHmacAlgSHA1, [secretData bytes], [secretData length], [clearTextData bytes], [clearTextData length], result);
    return [[NSData alloc] initWithBytes:result length:sizeof(result)];
}

+(NSString*) getUnixTimeString
{
    NSNumber* timestamp = [NSNumber numberWithLongLong:
                           [[NSDate date] timeIntervalSince1970]];
    return [NSString stringWithFormat:@"%@", timestamp];
}

+(NSString *) urlEncode: (const NSString*) toEncode
{
    return (NSString *)CFBridgingRelease(
              CFURLCreateStringByAddingPercentEscapes(
                kCFAllocatorDefault,
                (CFStringRef)toEncode,
                NULL,
                CFSTR(":/=,!$&'()*+;[]@#?"),
                kCFStringEncodingUTF8));
}

+(NSString *) urlDecode: (const NSString*) toDecode
{
    return (NSString*)CFBridgingRelease(
              CFURLCreateStringByReplacingPercentEscapesUsingEncoding(
                kCFAllocatorDefault,
                (CFStringRef)toDecode,
                CFSTR(""),
                kCFStringEncodingUTF8));
}

+(NSString*) formatQueryString:(NSDictionary*) parameters
{
    NSArray* sortedKeys = [[parameters allKeys] sortedArrayUsingSelector: @selector (compare:)];
    
    //create query string out of array list
    return [self joinForQuery: parameters usingOrderedKeys: sortedKeys];
}

+(NSDictionary*) parseQueryString: (NSString*) query
{
    NSMutableDictionary* queryParams = [[NSMutableDictionary alloc] initWithCapacity:10];

    //query is optional for an API call, so it may be null
    if([APIHelper isNullOrWhiteSpace: query])
        return queryParams;

    NSArray* sparams = [query componentsSeparatedByString: @"&"];
    
    for(NSString* qparam in sparams)
    {
        NSArray* tokens = [qparam componentsSeparatedByString: @"="];
        if(tokens.count != 2)
            continue;
        
        [queryParams setObject: [self urlDecode: tokens[1]]
                        forKey: [self urlDecode: tokens[0]]];
    }
    return queryParams;
}

+(NSString*) joinForHeader:(NSDictionary*) toJoin
{
    NSMutableString* sb = [[NSMutableString alloc] initWithCapacity:10];
    BOOL first = true;
    for(id key in toJoin)
    {
        if(!first)
        {
            [sb appendString: @","];
        }
        else
        {
            first = false;
        }
        [sb appendString: [[NSString alloc] initWithFormat:
                           @"%1$@=\"%2$@\"", key, [toJoin objectForKey:key]]];
    }
    return sb;
}

+(NSString*) joinForQuery:(NSDictionary*) toJoin usingOrderedKeys:(NSArray*) sortedKeys
{
    NSMutableString* sb = [[NSMutableString alloc] initWithCapacity:10];
    BOOL first = true;
    for(id key in sortedKeys)
    {
        if([key isEqual: @"realm"])
            continue;
        
        if(!first)
        {
            [sb appendString: @"&"];
        }
        else
        {
            first = false;
        }
        [sb appendString: [[NSString alloc] initWithFormat:
                           @"%1$@=%2$@", key, [toJoin objectForKey:key]]];
    }
    return sb;
}

+(NSString*) getHTTPMethodAsString:(HttpRequest*) request
{
    switch ([request httpMethod])
    {
        case HTTP_POST:
            return @"POST";
        case HTTP_PUT:
            return @"PUT";
        case HTTP_DELETE:
            return @"DELETE";
        case HTTP_PATCH:
            return @"PATCH";
        default:
            return @"GET";
    }
}

@end
